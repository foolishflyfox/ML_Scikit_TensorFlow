# 机器学习软件API设计的艺术
# &nbsp;&nbsp;&nbsp;&nbsp; --从scikit-learn项目中获得的经验

**本文由scikit-learn项目的众多作者总结；原文地址为：https://arxiv.org/pdf/1309.0238v1.pdf**

**摘要**：scikit-learn是一个日益流行的机器学习库。用Python语言编写，它被设计的尽可能简单和高效，非专业人士也可以轻松使用，能够应用在多种环境中。在这篇文章中，我们将介绍和讨论我们对该项目API设计的选择。特别地，我们将介绍所有学习和处理单元都具备的简单而又优雅的接口，之后，我们将讨论它在组合和可重用方面的优势。本文也将说明针对Python环境的一些实现细节，也将分析该库对用户和开发者来所面临的一些挑战。

## 1、介绍

*scikit-learn* 项目（Pedregosa等人，2011年开始）为 Python 编程语言提供了一个开源的机器学习库。这个项目的目标是在某一编程环境下提供高效、可以被广泛认可的机器学习工具，使得非机器学习的专业也能轻松使用，也可以在多种不同环境下复用这些工具。这个项目不是创造一种在特定领域使用的新语言，而是为一种通用高级语言提供一个机器学习的函数库。这个库包含分类学习算法、模型评价、选择工具、预处理程序等。该库在FreeBSD(也称simplified BSD)许可证下发布，在教学目的和商业目的下都可以使用。

*scikit-learn* 是一个库，用户可以通过Python程序从中导入一堆类和函数。使用 *scikit-learn* 需要具备基本的Python编程知识。不为非编程人员单独提供命令行接口(Command-Line Interface, CLI)和图形用户接口(Graphical User Interface, GUI)。但通过Python的交互式解释器以及其增强版的IPython中都可以完成交互式的使用，这两个解释器都为科学应用提供了一个类似 matlab 的工作环境。

该库的设计依赖于以 NumPy 和 SciPy 为主的数值和科学计算的包。NumPy通过一个连续数组实现了比原始数组更快的运算速度，SciPy在NumPy的基础上扩展了通用数值数据操作，其中有的操作是通过 Python/NumPy 实现，有的是通过对现存的 C/C++/Fortran 进行封装来实现。在这些技术的基础上，一系列被称为 *scikits* 的库被创建出来，和 SciPy 一起形成了特定领域的工具库。当前，最流行、功能最完整的两个库，一个是 *scikit-learn*，另一个是 [*scikit-image*](http://scikit-image.org)，主要用于图像处理。

2007年刚开始的时候，*scikit-learn* 主要有一个十几人组成的国际团队开发，大多数人是来自不同领域的研究人员（例如：计算机科学、神经科学、天体物理学 等）。这个项目也有很多贡献者的提供的bug修复以及性能改善。开发过程被放在[GitHub](https://github.com/scikit-learn)上，这个平台为这种合作方式提供了极大的便利。因为有大量的开发者参与进来，重点被放在这个项目的可维护性上。特别是，代码需要符合特定的质量准则，例如保持一致性和单元测试范围。所有的功能都需要提供文档和例子，重要的修改必须将代码提交给至少两名开发人员进行复查，不包括对修改建议的实现。

被成百上千的科学出版物所引用，帮助个人或团体在各种机器学习挑战赛取得胜利（如 Kaggle），从我们的仓库以及邮件列表中获得的统计信息，这些都能看出 *scikit-learn* 的流行程度。在写这篇文章的时候，这个项目在 Github 上的 watched数量达到1365人，forked 数量达到693次；在邮件列表中，每个月收到超过300封的邮件；版本控制日志显示项目有183个开发者，每个月在线文档有37000的下载量，有295000的访问量。

在本文中，我们不会深入介绍在创建这个库时候是如何作出设计选择的，具体介绍的是我们如何将常见的机器学习概念进行组织和实施的。在第二节中，我们首先介绍关键的API，在第三节中介绍在核心接口上建立起来的高级API的机制。第四节简单地介绍如何首先。第五节，以API为单位，比较 *scikit-learn* 和其他类似的主要项目。第六节，概述 *scikit-learn* 1.0 发行版的一些目标。在第七节中，我们对本文中的主要观点进行总结。

##2、 核心 API

*scikit-learn* 中所有的对象都统一用相同的方式组成基本API：一个评估器(estimator)接口，用于建立和训练模型；一个预测期(predictor)接口，用于数据的预测；一个转换器(transformer)接口，用于数据转换。在这一章节，我们将介绍着3个接口。在回顾了通用的原则和数据表示之后，我们将介绍这3个接口。

### 2.1、通用原则

我们的设计选择都是基于尽可能地避免框架代码扩散的原则下进行的。我们尽量采用简单的编程惯例，尽可能地使对象的方法数量最小化。API设计遵从下列的一些原则：

- 一致性：所有的对象（无论是基础的还是组合而成的）共享由有限的方法集组成的一致的接口。此接口以一致的方式记录在所有的对象上；
- 检查：构造函数参数和参数值记录在学习算法中，以公共属性的方式暴露；
- 类不扩散：学习算法是唯一的以自定义方式存在的对象。数据集以NumPy数组或SciPy稀疏矩阵表示。超参数名和值尽可能以标准的Python字符串或者数字表示。这使得 *scikit-learn* 容易使用，容易与其他的库结合使用；
- 结合： 许多机器学习任务可以表示为多种数据转换方法的序列或者说组合。有的学习算法也会被当成一个参数传入到其他的学习算法中。只要可行，类似算法都能通过多种学习算法的组合实现；
- 明智的默认值：不管什么时候，操作需要一个用户提供一个参数，*scikit-learn* 库都会提供一个默认值。默认值能够实现操作的一些基本功能。

### 2.2、数据表示

在大多数的机器学习任务中，数据被建模为一组变量。比如在监督学习任务中，目标是找到被称为特征的 $X_1,\cdots,X_p$ 输入变量与输出变量 $Y$ 的对应关系。一个样本被定义为这些变量成对组成的一对值（$[x_1,\cdots,x_p]^T, y$）。表示这种数据方式的最常用的数据结构是一对数值型矩阵：一个作为输入值，另一个作为输出值。这些矩阵中的每一行表示一个样本，每一列表示问题的一个变量。

在 *scikit-learn* 中，我们尽量选择能够表现矩阵的数据类型进行数据集的存储：对于密集型的数据集，使用Numpy多维数组进行编码；对于稀疏型的数据集，使用SciPy的稀疏矩阵进行存储。相比较于很多基于对象的构造方法，如Weka，我们的表示方法非常简单，这带来的主要好处是依赖于高效的NumPy和SciPy的向量化操作，我们仍然能够保持代码的可读性。做出这个选择的另一个动机是，通过其他的科学计算Python库，许多的科学计算用户已经对 NumPy稠密数组 和 SciPy稀疏矩阵 非常熟悉了。从实用的角度看，这些格式的数据能够被很多工具加载和转变，这使得我们的库能够很容易适应新的应用。而且，对于输入是文本文件或半结构化的对象，我们提供了 *vectorizer* 对象将他们高效转化为 NumPy 或 SciPy 的格式。

为了保持高效率，接口通常会在一次调用时处理一批采样而不是一个采样。分类和回归算法确实可以每次只对一个采样进行预测，这种情况下，*scikit-learn* 对象就不做优化了。（一些在线学习算法通常以一小批为单位进行处理。）批处理通过 NumPy 和 SciPy 避免了一些Python函数调用的固有开销，或者是减少了对元素动态类型的检查，使得整个效率得到提高。
